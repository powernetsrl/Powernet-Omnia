/*****************************************************/
/*        Definizione dei pin per ESP8266 mod        */
/*****************************************************/
#ifndef D0
  #define D0 16    // GPIO16
  #define D1 5     // GPIO5
  #define D2 4     // GPIO4
  #define D3 0     // GPIO0
  #define D4 2     // GPIO2
  #define D5 14    // GPIO14
  #define D6 12    // GPIO12
  #define D7 13    // GPIO13
  #define D8 15    // GPIO15
#endif

// MAPPING aggiornato:
// - POWER_PIN:         D0 (GPIO16)
// - INPUT_PIN:         D8 (GPIO15)
// - DS18B20_PIN:       D4 (GPIO2)
// - FLOW_SENSOR_PIN:   D3 (GPIO0)
// - TRIG_PIN:          D2 (GPIO4)
// - ECHO_PIN:          D5 (GPIO14)
// - SWITCH1_PIN:       D6 (GPIO12)
// - SWITCH2_PIN:       D7 (GPIO13)

#define POWER_PIN         D0
#define INPUT_PIN         D8
#define DS18B20_PIN       D4    // DS18B20 sul pin D4
#define FLOW_SENSOR_PIN   D3
#define TRIG_PIN          D2
#define ECHO_PIN          D5
#define SWITCH1_PIN       D6
#define SWITCH2_PIN       D7

/*****************************************************/
/*                      LIBRERIE                     */
/*****************************************************/
#include <ESP8266WiFi.h>
#include <WiFiManager.h>         // Gestione captive portal
#include <ESP8266WebServer.h>    // Server HTTP
#include <PubSubClient.h>        // MQTT
#include <ArduinoJson.h>
#include <ArduinoOTA.h>
#include <EEPROM.h>

// Librerie per DS18B20
#include <OneWire.h>
#include <DallasTemperature.h>

/*****************************************************/
/*              COSTANTI & CONFIGURAZIONI            */
/*****************************************************/
const char* FIRMWARE_VERSION = "1.0.1";
const char* FIRMWARE_REPO_URL = "https://github.com/powernetsrl/Powernet-Omnia/tree/firmware";

// Broker MQTT (modifica se necessario)
const char* THINGSBOARD_SERVER = "powernetsrl.ddns.net";
const int   THINGSBOARD_PORT   = 9003;

// ID Dispositivo (generato dal chip)
String IDDispositivo;

// Topic MQTT
const char* TELEMETRY_TOPIC = "v1/devices/me/telemetry";
const char* ATTRIBUTE_TOPIC = "v1/devices/me/attributes";

// Timer per la telemetria e per il riconnettimento MQTT
unsigned long previousMillis = 0;
unsigned long reconnectPreviousMillis = 0;
const long    reconnectInterval = 5000;

// Variabili per le misurazioni dei sensori
float distanceCm = 0.0;            // Misurazione distanza (HC‑SR04) in cm
float voltageReading = 0.0;        // Tensione letta dal sensore batteria su A0
float lastFlowRate = 0.0;          // Portata (L/min)
float temperatureC = 0.0;          // Temperatura in °C

// Contatore impulsi per il sensore di flusso
volatile unsigned long flowPulseCount = 0;

/*****************************************************/
/*           CONFIGURAZIONE PERSISTENTE              */
/*****************************************************/
#define CONFIG_MAGIC "CNFG"
#define EEPROM_SIZE 512

struct ConfigData {
  char magic[4];             // Deve contenere CONFIG_MAGIC
  int tankHeight;            // Altezza del serbatoio (cm) – range 10-400
  bool switch1State;         // Stato dello Switch 1
  bool switch2State;         // Stato dello Switch 2
  float batteryMaxVoltage;   // Valore massimo atteso della batteria (es. 25 V)
  float flowCalibration;     // Impulsi per litro (per il sensore di flusso)
  int telemetryInterval;     // Intervallo in secondi per l'invio della telemetria (1-3600)
};

ConfigData config;
  
/*****************************************************/
/*             Wi-Fi, MQTT e Server HTTP             */
/*****************************************************/
WiFiClient espClient;
PubSubClient mqttClient(espClient);
ESP8266WebServer server(80);

/*****************************************************/
/*             PROTOTIPI DELLE FUNZIONI              */
/*****************************************************/
String generateUniqueID();
void setupOTA();
void reconnectMQTT();
void mqttCallback(char* topic, byte* payload, unsigned int length);
float measureDistance();
String getHTMLPage();
void loadConfig();
void saveConfig();

// HTTP Handler
void handleRoot();

// ISR per il sensore di flusso
void IRAM_ATTR flowPulseISR() {
  flowPulseCount++;
}

/*****************************************************/
/*          INIZIALIZZAZIONE DS18B20                 */
/*****************************************************/
OneWire oneWire(DS18B20_PIN);
DallasTemperature ds18b20(&oneWire);

/*****************************************************/
/*          GENERAZIONE ID UNIVOCO (Chip ID)         */
/*****************************************************/
String generateUniqueID() {
  uint32_t chipId = ESP.getChipId();
  char idStr[9];
  snprintf(idStr, sizeof(idStr), "%08X", chipId);
  return String(idStr);
}

/*****************************************************/
/*             CARICA LA CONFIGURAZIONE              */
/*****************************************************/
void loadConfig() {
  EEPROM.begin(EEPROM_SIZE);
  EEPROM.get(0, config);
  if (strncmp(config.magic, CONFIG_MAGIC, 4) != 0) {
    Serial.println("Config non valida, imposto i valori di default.");
    strncpy(config.magic, CONFIG_MAGIC, 4);
    config.tankHeight = 100;         // default: 100 cm
    config.switch1State = false;
    config.switch2State = false;
    config.batteryMaxVoltage = 25.0;   // default: 25 V
    config.flowCalibration = 450.0;    // default: 450 impulsi per litro
    config.telemetryInterval = 10;     // default: 10 secondi
    saveConfig();
  } else {
    Serial.println("Config caricata dall'EEPROM:");
    Serial.print("tankHeight: "); Serial.println(config.tankHeight);
    Serial.print("switch1State: "); Serial.println(config.switch1State);
    Serial.print("switch2State: "); Serial.println(config.switch2State);
    Serial.print("batteryMaxVoltage: "); Serial.println(config.batteryMaxVoltage);
    Serial.print("flowCalibration: "); Serial.println(config.flowCalibration);
    Serial.print("telemetryInterval: "); Serial.println(config.telemetryInterval);
  }
}

/*****************************************************/
/*             SALVA LA CONFIGURAZIONE             */
/*****************************************************/
void saveConfig() {
  EEPROM.put(0, config);
  EEPROM.commit();
}

// Variabile per controllare se il POWER_PIN è già stato attivato
bool powerPinLoaded = false;

/*****************************************************/
/*                     SETUP                         */
/*****************************************************/
void setup() {
  Serial.begin(115200);
  delay(100);

  // Inizializza il DS18B20
  ds18b20.begin();
  Serial.print("Numero di sensori DS18B20 rilevati: ");
  Serial.println(ds18b20.getDeviceCount());

  // Genera e mostra l'ID dispositivo
  IDDispositivo = generateUniqueID();
  Serial.print("ID Dispositivo: ");
  Serial.println(IDDispositivo);

  // Carica la configurazione persistente da EEPROM
  loadConfig();

  // Imposta i pin per HC‑SR04
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  digitalWrite(TRIG_PIN, LOW);

  // Imposta il pin di ingresso unificato (precedentemente contatti puliti)
  pinMode(INPUT_PIN, INPUT);

  // Imposta i pin per gli switch (uscite) e applica lo stato salvato
  pinMode(SWITCH1_PIN, OUTPUT);
  pinMode(SWITCH2_PIN, OUTPUT);
  digitalWrite(SWITCH1_PIN, config.switch1State ? HIGH : LOW);
  digitalWrite(SWITCH2_PIN, config.switch2State ? HIGH : LOW);

  // Imposta il pin del sensore di flusso e attacca l'interrupt
  pinMode(FLOW_SENSOR_PIN, INPUT_PULLUP);
  attachInterrupt(digitalPinToInterrupt(FLOW_SENSOR_PIN), flowPulseISR, RISING);

  // Imposta il POWER_PIN come output e inizialmente a LOW
  pinMode(POWER_PIN, OUTPUT);
  digitalWrite(POWER_PIN, LOW);

  // Configura WiFi tramite WiFiManager con AP denominato "Powernet_Omnia_XXXXXXXX"
  WiFiManager wifiManager;
  String apName = "Powernet_Omnia_" + IDDispositivo;
  wifiManager.setConfigPortalTimeout(180);
  if (!wifiManager.autoConnect(apName.c_str())) {
    Serial.println("Connessione WiFi fallita, riavvio...");
    ESP.restart();
  }
  Serial.println("WiFi connesso!");
  Serial.print("IP: "); Serial.println(WiFi.localIP());

  // Configura MQTT
  mqttClient.setServer(THINGSBOARD_SERVER, THINGSBOARD_PORT);
  mqttClient.setCallback(mqttCallback);

  // Configura OTA
  setupOTA();
  ArduinoOTA.begin();

  // Configura il server HTTP
  server.on("/", handleRoot);
  server.begin();
  Serial.println("Server HTTP avviato");

  // Invia attributi firmware via MQTT (se connesso)
  if (mqttClient.connected()) {
    StaticJsonDocument<256> doc;
    doc["firmware_version"] = FIRMWARE_VERSION;
    doc["firmware_repo"]    = FIRMWARE_REPO_URL;
    char buffer[256];
    size_t n = serializeJson(doc, buffer);
    mqttClient.publish(ATTRIBUTE_TOPIC, buffer, n);
  }
}

/*****************************************************/
/*                      LOOP                         */
/*****************************************************/
void loop() {
  ArduinoOTA.handle();
  
  // Dopo 5 secondi dall'avvio, attiva il POWER_PIN (passa a HIGH)
  if (!powerPinLoaded && millis() >= 5000) {
    digitalWrite(POWER_PIN, HIGH);
    powerPinLoaded = true;
    Serial.println("POWER_PIN attivato (HIGH) dopo 5 secondi.");
  }
  
  if (!mqttClient.connected()) {
    reconnectMQTT();
  }
  mqttClient.loop();
  server.handleClient();

  unsigned long now = millis();
  // Invio telemetria ogni config.telemetryInterval secondi
  if (now - previousMillis >= (unsigned long)config.telemetryInterval * 1000UL) {
    previousMillis = now;

    // Richiedi la temperatura dal DS18B20
    ds18b20.requestTemperatures();
    temperatureC = ds18b20.getTempCByIndex(0);

    // Misura la distanza con HC‑SR04
    distanceCm = measureDistance();
    Serial.print("Distanza misurata: ");
    Serial.print(distanceCm);
    Serial.println(" cm");

    // Lettura della tensione tramite ADC A0 e calcolo della percentuale della batteria
    int adcValue = analogRead(A0);
    voltageReading = adcValue * (config.batteryMaxVoltage / 1023.0);
    float batteryPercent = (voltageReading / config.batteryMaxVoltage) * 100.0;
    if (batteryPercent < 0) batteryPercent = 0;
    if (batteryPercent > 100) batteryPercent = 100;

    // Gestione del sensore di flusso: leggi e resetta il contatore in modo atomico
    noInterrupts();
    unsigned long pulseCount = flowPulseCount;
    flowPulseCount = 0;
    interrupts();
    lastFlowRate = (pulseCount / config.flowCalibration) * (60.0 / config.telemetryInterval);

    // Prepara i dati in formato JSON per l'invio via MQTT
    StaticJsonDocument<256> doc;
    float waterLevelPercent = 0;
    if (distanceCm >= 0) {
      waterLevelPercent = ((config.tankHeight - distanceCm) / (float)config.tankHeight) * 100;
      if (waterLevelPercent < 0) waterLevelPercent = 0;
      if (waterLevelPercent > 100) waterLevelPercent = 100;
    }
    doc["water_level_percent"] = waterLevelPercent;
    doc["rssi_db"] = WiFi.RSSI();
    doc["ip"] = WiFi.localIP().toString();
    
    doc["voltage"] = voltageReading;
    doc["battery_percent"] = batteryPercent;
    
    doc["flow_rate"] = lastFlowRate;
    doc["temperature_c"] = temperatureC;
    
    // Invia anche l'SSID della rete WiFi
    doc["ssid"] = WiFi.SSID();
    
    // Inoltra lo stato degli switch
    doc["switch1"] = config.switch1State;
    doc["switch2"] = config.switch2State;
    
    // Inoltra lo stato dell'INPUT_PIN (ex dry_contact)
    doc["input_pin"] = (digitalRead(INPUT_PIN) == HIGH);

    char buffer[256];
    size_t n = serializeJson(doc, buffer);
    if (mqttClient.publish(TELEMETRY_TOPIC, buffer, n)) {
      Serial.println("MQTT -> Dati inviati con successo");
    } else {
      Serial.println("MQTT -> Errore nell'invio dei dati");
    }
  }
}

/*****************************************************/
/*      FUNZIONE DI RICONNESSIONE MQTT PERIODICA     */
/*****************************************************/
void reconnectMQTT() {
  unsigned long now = millis();
  if (now - reconnectPreviousMillis >= reconnectInterval) {
    reconnectPreviousMillis = now;
    Serial.print("Tentativo connessione MQTT...");
    if (mqttClient.connect("Powernet_Omnia", IDDispositivo.c_str(), NULL)) {
      Serial.println(" riuscito");
      mqttClient.subscribe(ATTRIBUTE_TOPIC);

      StaticJsonDocument<256> doc;
      doc["firmware_version"] = FIRMWARE_VERSION;
      doc["firmware_repo"]    = FIRMWARE_REPO_URL;
      char buffer[256];
      size_t n = serializeJson(doc, buffer);
      mqttClient.publish(ATTRIBUTE_TOPIC, buffer, n);
    } else {
      Serial.print(" fallito, rc=");
      Serial.println(mqttClient.state());
      Serial.println(" Riprovo...");
    }
  }
}

/*****************************************************/
/*                 CALLBACK MQTT                     */
/*****************************************************/
void mqttCallback(char* topic, byte* payload, unsigned int length) {
  Serial.print("MQTT su topic: ");
  Serial.println(topic);
  
  String message;
  for (unsigned int i = 0; i < length; i++) {
    message += (char)payload[i];
  }
  Serial.print("Payload: ");
  Serial.println(message);

  StaticJsonDocument<256> doc;
  DeserializationError error = deserializeJson(doc, message);
  if (!error) {
    bool updated = false;
    if (doc.containsKey("tankHeight")) {
      int newTankHeight = doc["tankHeight"];
      if (newTankHeight >= 10 && newTankHeight <= 400) {
        config.tankHeight = newTankHeight;
        Serial.print("Nuova tankHeight settata a: ");
        Serial.println(config.tankHeight);
        updated = true;
      } else {
        Serial.println("tankHeight fuori range (10-400). Ignorato.");
      }
    }
    if (doc.containsKey("batteryMaxVoltage")) {
      float newBatteryMax = doc["batteryMaxVoltage"];
      if (newBatteryMax >= 1 && newBatteryMax <= 25) {
        config.batteryMaxVoltage = newBatteryMax;
        Serial.print("Nuovo batteryMaxVoltage settato a: ");
        Serial.println(config.batteryMaxVoltage);
        updated = true;
      } else {
        Serial.println("batteryMaxVoltage fuori range (1-25 V). Ignorato.");
      }
    }
    if (doc.containsKey("flowCalibration")) {
      float newFlowCal = doc["flowCalibration"];
      if (newFlowCal >= 1 && newFlowCal <= 10000) {
        config.flowCalibration = newFlowCal;
        Serial.print("Nuovo flowCalibration settato a: ");
        Serial.println(config.flowCalibration);
        updated = true;
      } else {
        Serial.println("flowCalibration fuori range (1-10000). Ignorato.");
      }
    }
    if (doc.containsKey("telemetryInterval")) {
      int newInterval = doc["telemetryInterval"];
      if (newInterval >= 1 && newInterval <= 3600) {
        config.telemetryInterval = newInterval;
        Serial.print("Nuovo telemetryInterval settato a: ");
        Serial.println(config.telemetryInterval);
        updated = true;
      } else {
        Serial.println("telemetryInterval fuori range (1-3600 secondi). Ignorato.");
      }
    }
    if (doc.containsKey("switch1")) {
      config.switch1State = doc["switch1"].as<bool>();
      Serial.print("Switch 1 stato: ");
      Serial.println(config.switch1State ? "true" : "false");
      updated = true;
    }
    if (doc.containsKey("switch2")) {
      config.switch2State = doc["switch2"].as<bool>();
      Serial.print("Switch 2 stato: ");
      Serial.println(config.switch2State ? "true" : "false");
      updated = true;
    }
    if (updated) {
      saveConfig();
      digitalWrite(SWITCH1_PIN, config.switch1State ? HIGH : LOW);
      digitalWrite(SWITCH2_PIN, config.switch2State ? HIGH : LOW);
    }
  } else {
    Serial.print("Errore nella decodifica JSON: ");
    Serial.println(error.c_str());
  }
}

/*****************************************************/
/*     FUNZIONE PER MISURARE LA DISTANZA (HC-SR04)   */
/*****************************************************/
float measureDistance() {
  long duration;
  float distance;
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  duration = pulseIn(ECHO_PIN, HIGH, 30000); // Timeout di 30 ms
  if (duration == 0) {
    return -1;
  }
  distance = duration * 0.034 / 2;
  return distance;
}

/*****************************************************/
/*           HANDLER HTTP: PAGINA PRINCIPALE         */
/*****************************************************/
void handleRoot() {
  // Se viene richiesto un riavvio, rispondi e riavvia
  if (server.hasArg("restart")) {
    Serial.println("Riavvio richiesto tramite dashboard.");
    server.send(200, "text/html", "<html><body><h1>Riavvio in corso...</h1></body></html>");
    delay(1000);
    ESP.restart();
    return;
  }
  
  bool updated = false;
  // Gestione dei parametri di configurazione tramite dashboard
  if (server.hasArg("tankHeight")) {
    int newTankHeight = server.arg("tankHeight").toInt();
    if (newTankHeight >= 10 && newTankHeight <= 400) {
      config.tankHeight = newTankHeight;
      Serial.print("Nuova tankHeight impostata tramite dashboard a: ");
      Serial.println(config.tankHeight);
      updated = true;
    } else {
      Serial.println("tankHeight fuori range (10-400).");
    }
  }
  if (server.hasArg("batteryMaxVoltage")) {
    float newBatteryMax = server.arg("batteryMaxVoltage").toFloat();
    if (newBatteryMax >= 1 && newBatteryMax <= 25) {
      config.batteryMaxVoltage = newBatteryMax;
      Serial.print("Nuovo batteryMaxVoltage impostato tramite dashboard a: ");
      Serial.println(config.batteryMaxVoltage);
      updated = true;
    } else {
      Serial.println("batteryMaxVoltage fuori range (1-25 V).");
    }
  }
  if (server.hasArg("flowCalibration")) {
    float newFlowCal = server.arg("flowCalibration").toFloat();
    if (newFlowCal >= 1 && newFlowCal <= 10000) {
      config.flowCalibration = newFlowCal;
      Serial.print("Nuovo flowCalibration impostato tramite dashboard a: ");
      Serial.println(config.flowCalibration);
      updated = true;
    } else {
      Serial.println("flowCalibration fuori range (1-10000).");
    }
  }
  if (server.hasArg("telemetryInterval")) {
    int newInterval = server.arg("telemetryInterval").toInt();
    if (newInterval >= 1 && newInterval <= 3600) {
      config.telemetryInterval = newInterval;
      Serial.print("Nuovo telemetryInterval impostato tramite dashboard a: ");
      Serial.println(config.telemetryInterval);
      updated = true;
    } else {
      Serial.println("telemetryInterval fuori range (1-3600 secondi).");
    }
  }
  
  // Se la configurazione è stata aggiornata, salva e applica gli switch
  if (updated) {
    saveConfig();
    digitalWrite(SWITCH1_PIN, config.switch1State ? HIGH : LOW);
    digitalWrite(SWITCH2_PIN, config.switch2State ? HIGH : LOW);
  }
  
  // Genera la pagina HTML
  server.send(200, "text/html", getHTMLPage());
}

/*****************************************************/
/*            PAGINA HTML CON INFORMAZIONI           */
/*****************************************************/
String getHTMLPage() {
  // Helper per visualizzare lo stato con un pallino colorato
  auto dotColor = [&](bool st) {
    return String("<span style='display:inline-block;width:12px;height:12px;border-radius:50%;margin-left:5px;background-color:") +
           (st ? "green" : "red") + ";'></span>";
  };

  String style = R"====(
    <style>
      body { font-family: Arial, sans-serif; background: #f3f3f3; color: #333; padding: 20px; }
      .container { max-width: 800px; margin: auto; background: #fff; padding: 20px; border-radius: 5px; }
      h2 { margin-top: 0; }
      .btn { display: inline-block; background: #2196F3; color: #fff; padding: 10px 20px; text-decoration: none; border-radius: 5px; }
      .btn:hover { background: #1976D2; }
      input[type="number"] { padding: 5px; margin: 5px 0; }
      input[type="submit"] { padding: 5px 10px; }
      footer { text-align: center; font-size: 0.85em; color: #666; margin-top: 20px; }
      .logo { display: block; margin: 0 auto 20px auto; }
    </style>
  )====";

  String html = "<!DOCTYPE html><html><head><meta charset='UTF-8'><title>Powernet_Omnia Control</title>";
  html += style;
  html += "</head><body><div class='container'>";
  
  // Inserimento del logo
  html += "<div style='text-align:center;'><img class='logo' src='https://static.wixstatic.com/media/64ffab_a4006984a795460085d22ad4f7c90a1a~mv2.png/v1/fill/w_54,h_49,al_c,q_85,usm_0.66_1.00_0.01,enc_avif,quality_auto/Logo%20PoW.png' alt='Logo Powernet'></div>";
  
  html += "<h2>Device Info</h2>";
  html += "<p><strong>ID Dispositivo:</strong> " + IDDispositivo + "</p>";
  html += "<p><strong>WiFi:</strong> " + String((WiFi.status() == WL_CONNECTED) ? "Connesso" : "Disconnesso") + dotColor(WiFi.status() == WL_CONNECTED) + "</p>";
  html += "<p><strong>MQTT:</strong> " + String(mqttClient.connected() ? "Connesso" : "Disconnesso") + dotColor(mqttClient.connected()) + "</p>";
  
  html += "<hr><h2>Sensor Data</h2>";
  if (distanceCm < 0) {
    html += "<p><strong>Distanza:</strong> Errore o fuori range</p>";
  } else {
    html += "<p><strong>Distanza:</strong> " + String(distanceCm, 2) + " cm</p>";
  }
  html += "<p><strong>Tank Height:</strong> " + String(config.tankHeight) + " cm</p>";
  html += "<p><strong>Water Level:</strong> " + String(((config.tankHeight - distanceCm) / (float)config.tankHeight) * 100, 2) + " %</p>";
  html += "<p><strong>Voltage:</strong> " + String(voltageReading, 2) + " V</p>";
  html += "<p><strong>Battery Level:</strong> " + String((voltageReading / config.batteryMaxVoltage) * 100, 2) + " %</p>";
  html += "<p><strong>Flow Rate:</strong> " + String(lastFlowRate, 2) + " L/min</p>";
  html += "<p><strong>Temperature:</strong> " + String(temperatureC, 2) + " °C</p>";
  
  html += "<hr><h2>Input Pin</h2>";
  html += "<p><strong>Stato Input:</strong> " + String(digitalRead(INPUT_PIN) == HIGH ? "Attivo" : "Inattivo") + "</p>";
  
  html += "<hr><h2>Configurazione</h2>";
  html += "<form action='/' method='get'>";
  html += "<label for='tankHeight'>Altezza serbatoio (cm):</label><br>";
  html += "<input type='number' id='tankHeight' name='tankHeight' min='10' max='400' value='" + String(config.tankHeight) + "' required><br>";
  html += "<label for='batteryMaxVoltage'>Battery Max Voltage (V):</label><br>";
  html += "<input type='number' id='batteryMaxVoltage' name='batteryMaxVoltage' min='1' max='25' step='0.1' value='" + String(config.batteryMaxVoltage, 2) + "' required><br>";
  html += "<label for='flowCalibration'>Flow Calibration (impulsi per litro):</label><br>";
  html += "<input type='number' id='flowCalibration' name='flowCalibration' min='1' max='10000' step='0.1' value='" + String(config.flowCalibration, 1) + "' required><br>";
  html += "<label for='telemetryInterval'>Telemetry Interval (secondi):</label><br>";
  html += "<input type='number' id='telemetryInterval' name='telemetryInterval' min='1' max='3600' step='1' value='" + String(config.telemetryInterval) + "' required><br><br>";
  html += "<input type='submit' value='Aggiorna'>";
  html += "</form>";
  
  html += "<hr><h2>Controllo Switch</h2>";
  html += "<p>Switch 1: " + String(config.switch1State ? "true" : "false") + " &nbsp; <a class='btn' href='/?switch1=true'>Accendi</a> <a class='btn' href='/?switch1=false'>Spegni</a></p>";
  html += "<p>Switch 2: " + String(config.switch2State ? "true" : "false") + " &nbsp; <a class='btn' href='/?switch2=true'>Accendi</a> <a class='btn' href='/?switch2=false'>Spegni</a></p>";
  
  html += "<hr><h2>Strumenti di Sistema</h2>";
  html += "<p><a class='btn' href='/?restart=1'>Riavvia Dispositivo</a></p>";
  
  // Footer aggiornato
  html += "</div><footer>";
  html += "Powernet Srl - ROC 25294 - REA 317484 - P.IVA 06387880823<br>";
  html += "Sede Legale - PALERMO (PA) VIA MARIANO STABILE 105 CAP 90139<br>";
  html += "Sedi Operativa Capaci - Via Sant' Erasmo 37 Capaci, PA 90040<br>";
  html += "SDI: M5UXCR1 - PEC: powernetsrls@pec.it";
  html += "</footer></body></html>";
  
  return html;
}

/*****************************************************/
/*               SETUP OTA (Over-The-Air)            */
/*****************************************************/
void setupOTA() {
  ArduinoOTA.onStart([]() {
    String type = (ArduinoOTA.getCommand() == U_FLASH) ? "Sketch" : "Filesystem";
    Serial.println("OTA Start: " + type);
  });
  ArduinoOTA.onEnd([]() {
    Serial.println("\nOTA completato!");
  });
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    float perc = (progress / (float)total) * 100;
    Serial.printf("OTA: %.2f%%\r", perc);
  });
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("OTA Errore [%u]\n", error);
  });
  ArduinoOTA.setHostname("Powernet_Omnia");
}
